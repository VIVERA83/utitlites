# Полезные утилиты

Репозиторий посвящен утилитам которые были написаны мной и используются в некоторых моих проектах.

<span id="0"></span>

1. [timeout](#1) - декоратор, принудительно завершает исполнение функции или другого вызываемого объекта
2. [before_execution](#2) - асинхронный декоратор, пытается исполнить функцию, за отведенное время, несмотря на
   исключения

___

### <span id="1">1. </span><span style="color:purple">timeout</span>

</span><span style="color:orange">__Описание:__</span>

Декоратор, который принудительно останавливает и завершает выполнение вызываемого объекта.

Бывает так что выполнение функции может зависнуть по разным причинам, например ждет ответа от удавленного источника,
либо выполняет сложную вычислительную операцию, а времянки ждать результата нет. А бывает так что функция может
некорректно работать и зациклится в вечный цикл. Либо в тестах необходимо ограничить время исполнения вызываемой
функции.
Для таких случаев можно попробовать использовать timeout.

Листинг функции можно посмотреть [тут](utils%2Ftimeout_decorator.py)

Например:

* функция
* экземпляр(объекта) класса с объявленным
  методом `__call__`, подробнее о `__call__`
  смотри [тут](https://proproprogs.ru/python_oop/magicheskiy-metod-call-funktory-i-klassy-dekoratory?ysclid=lhacw8ssek103695718)
* метод экземпляра(объекта) класса
  Корректно работать с асинхронными функциями не будет, так как является обычным декоратором без поддержки асинхронного
  исполнения.
  Да и для остановки асинхронных функций есть несколько способов. Подробности можно посмотреть
  в [asyncio](https://docs.python.org/3/library/asyncio-task.html)
  или [тут](https://docs-python.ru/standart-library/modul-asyncio-python/funktsija-wait-for-modulja-asyncio/)

</span><span style="color:orange">__Пример использования:__</span>

```python
from utils.timeout_decorator import timeout
from time import sleep


def work_sleep(sec: int) -> str:
    sleep(sec)
    return "Wake Up"


@timeout(timeout_error=False)
def work_sleep_2(sec: int) -> str:
    sleep(sec)
    return "Wake Up"


if __name__ == '__main__':
    work_1 = timeout(time_out=2)(work_sleep)
    print(work_sleep_2(1))  # Wake Up
    print(work_sleep_2(3))  # None
    print(work_1(3))  # raise TimeoutError

```

Так же примеры использования можно посмотреть [тут](examples%2Ftimeout_decorator.py)

### [Наверх](#0) [&#9757;](#0)

----

### <span id="1">1. </span><span style="color:purple">before_execution</span>

</span><span style="color:orange">__Описание:__</span>

Декоратор для асинхронных функций или методов объектов, который за указанное время пытается выполнить функцию,
в случае возникновения ошибки делает попытку снова исполнить функцию через указанный промежуток времени +
случайное время в пределах 1 секунды.

Возможное применение:
Предположим, идёт подключение к ElasticSearch в момент запуска docker compose файла.
Как известно depends_on - не дожидается полной загрузки зависимости, и может случиться такая ситуация
когда ElasticSearch полностью еще не прогрузился, а приложение уже пытается подключиться к серверу.
В таком случае вылетает исключение и приложение вероятнее всего корректно работать уже не будет.

Листинг функции можно посмотреть [тут](utils%2Fbackoff.py)

Так же примеры использования можно посмотреть [тут](examples%2Fbackoff.py)

### [Наверх](#0) [&#9757;](#0)

___

